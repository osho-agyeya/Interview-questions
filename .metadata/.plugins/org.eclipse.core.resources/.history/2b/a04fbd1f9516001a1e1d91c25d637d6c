//doe

//this is using kruskal's algorithm

package interviewbit;

import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;
import java.util.TreeSet;

public class Commutable_Islands {
	
	
	/*
	public int solve(int A, int[][] B) {
        
        Arrays.sort(B, new Comparator<int[]>(){
            public int compare(int[] arr1, int[] arr2){
                return arr1[2] - arr2[2];
            }
        });
        
        //for (int i = 0; i < B.length; i++){
        //    System.out.println(Arrays.toString(B[i]));
        //}
        
        int ans = 0;
        int count = 0;
        
        int[] parent = new int[A];
        int[] rank = new int[A];
        
        Arrays.fill(parent, -1);
        Arrays.fill(rank, 1);
        
        for (int i = 0; i < B.length; i++){
            if (count == A)
                break;
                
            int x = find(parent, B[i][0] - 1);
            int y = find(parent, B[i][1] - 1);
            
            if (x == y)
                continue;
                
            if (rank[x] < rank[y]){
                parent[x] = y;
            }else if(rank[x] > rank[y]){
                parent[y] = x;
            }else{
                parent[x] = y;
                rank[y]++;
            }
            
            ans += B[i][2];
            count++;
        }
        
        return ans;
    }
    
    int find(int[] parent, int v){
        if (parent[v] == -1){
            return v;
        }else{
            parent[v] = find(parent, parent[v]);
            return parent[v];
        }
        
        
    }
    
    */
	
	public int solve(int A, int[][] B) {
	    int ans=0;
	    //adjacency list
	    Map<Integer, Map<Integer, Integer>> costs = new HashMap<>();
	    for (int[] f : B) {
	        if (!costs.containsKey(f[0])) costs.put(f[0], new HashMap<>());
	        costs.get(f[0]).put(f[1], f[2]);
	        if (!costs.containsKey(f[1])) costs.put(f[1], new HashMap<>());
	        costs.get(f[1]).put(f[0], f[2]);
	    }
	    TreeSet<int[]> pq = new TreeSet<>((a, b) -> (a[1] - b[1]));
	    boolean notInPQ[]=new boolean[A+1];
	    int valueInPQ[]=new int[A+1];
	    for(int i =0;i<A;i++){
	        pq.add(new int[]{i+1,i==0?0:Integer.MAX_VALUE});
	        valueInPQ[i+1]=(i==0?0:Integer.MAX_VALUE);
	    }
	    while(!pq.isEmpty()){
	        int[] removed=pq.pollFirst();
	        int u=removed[0];
	        notInPQ[u]=true;
	        int key=removed[1];
	        valueInPQ[u]=key;
	        ans+=key;
	        Map<Integer,Integer> neighbours=costs.get(u);
	        neighbours.forEach((v,w)->{
	            if(!notInPQ[v]){
	               if(w<valueInPQ[v]){
	                   pq.remove(new int[]{v,valueInPQ[v]});
	                   pq.add(new int[]{v,w});
	                   valueInPQ[v]=w;
	               } 
	            }
	        });
	    }
	    
	    return ans;
	        
	    }
	
	public static void main(String[] args) {
		System.out.println(new Commutable_Islands().solve(4, new int[][]{{1,2,1},{2,3,4},{1,4,3},{4,3,2},{1,3,10}}));
	}
    
    

}
